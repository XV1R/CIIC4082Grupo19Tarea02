#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    TIMER_A0_ISR            ; set vector for 'TIMER_A0_ISR' routine

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        DC16    PORT1_ISR               ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).

;placing CPURUM Ram at beginning of actual RAM
; Primeros 16 bytes son RAM de CPURUM
        ORG     0x01C00
cpuRAM  ;     INSTRUCTIONS USED TO TEST DECODING
        ; TODO: Cuando movemos valores a registro, padding ocurre por ser 16 bits
        db      0x20, 0x6f, 0xea, 0xcf, 0xf4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
progCount             db      0 
timeoftimer           db      0
runningInDebugger     db      0
instructionMasks                        ; first 6 bits to AND with and get opcode
        db      0

start   db      0

begin   db      0

counter db      1

p1counter db    1

instrIn db 0

delayCounter dw 62500

debouncing dw 500

instCounter dw 0



        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack


UnlockGPIO:
        bic.w   #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on default
                                        ; high-impedance mode to activate
                                        ; previously configured port settings

	;Initialize LCD_C
    	;ACLK, Divider = 1, Pre-divider = 16; 4-pin MUX
	MOV.W   #0x041e,&LCDCCTL0

    	;VLCD generated internally,
    	;V2-V4 generated internally, v5 to ground
    	;Set VLCD voltage to 2.60v
    	;Enable charge pump and select internal reference for it
    	MOV.W   #0x0208,&LCDCVCTL

	MOV.W   #0x8000,&LCDCCPCTL   ;Clock synchronization enabled

	MOV.W   #2,&LCDCMEMCTL       ;Clear LCD memory

        ;Initialize LCD segments 0 - 21; 26 - 43
        MOV.W   #0xFFFF,&LCDCPCTL0
	MOV.W   #0xfc3f,&LCDCPCTL1
    	MOV.W   #0x0fff,&LCDCPCTL2


	;Turn LCD on
	BIS.W   #1,&LCDCCTL0

        mov     #CCIE, &TA0CCTL0              ; Enable TACCR0 interrupt
        mov     #TASSEL_2+MC_1+ID_3, &TA0CTL  ;Set timer according to next table
        nop
        mov     #0x0, &TA0CCR0

	nop
        
        bic.b   #0xFF,&P1SEL0           ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1           ; Digital I/O is the default
        bic.b   #0xFF,&P9SEL0
        bic.b   #0xFF,&P9SEL1

        mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for output

        bis.b   #0xFF,&P9DIR            ; Set all P9 pins for output

        mov.b   #00000110B, &P1REN            ; P1.1 Resistor enabled as pullup
        bis.b   #00000110B, &P1OUT            ; resistor because pushing button
                                        ; connects it to ground

        bic.b   #0x01, &P1OUT
        bic.b   #0x80, &P9OUT

        mov.b   p1counter, R4

        bis.b   #00000110B, &P1IE             ; Enable interrupt at P1.1
        bis.b   #02h, &P1IES            ; Set interrupt on high-to-low
                                        ; transition of P1.1
        ; Uses SMCLK and up mode
        ; TASSELx        MCx (mode control)                IDx (input divider)
        ; 00 -> TACLK    00 -> Stop                        00 -> /1
        ; 01 -> ACLK     01 -> Up mode (up to TACCR0)      01 -> /2
        ; 10 -> SMCLK    10 -> Continuous (up to 0FFFFh)   02 -> /4
        ; 11 -> INCLK    11 -> Up/down (top on TACCR0)     03 -> /8

        ; period = cycles * divider / SMLCK
        ; Assuming SMLCK = 1 MHz, divider = 8 and period = 0.5 seg
        ; cycles = 62500.  With period = 0.5 LED turn on every 1 second
        ;mov     #62500, &TA0CCR0        ; Set the timer capture compare register 0
        nop                   ; the architecture
        bis.w   #GIE,SR 	        ; Interrupts enabled (same as eint)
                                        ; so that the micro reacts to
                                        ; interrupts
        nop
        ;bis     #GIE+LPM0, SR
        nop                             ; Wait after setting interrupt bit

        ;bis     #LPM0,SR                ; Enter Low Power Mode 0
        nop


main:   NOP                             ; main program

        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        ;mov.b &P1IN, R4       

        mov.w #0, instCounter

        cmp.b #1, runningInDebugger
        jeq startProgram

loopover:                               ; stuck in looping names
        cmp.b   #1, begin
        jne     loopover

startProgram:
        
        bic.b   #00000110B, &P1IE       ;masks interrupts
        bic.b   #02h, &P1IES

         ;mov.b #00000001B, R5
         ;call #recieveInput  
         
        nop
        ;bis     #GIE+LPM0, SR
        ;nop

        ;start executing instructions from ram
        clr     R5
        clr     R6
        clr     R7
        clr     R8     
        clr     R9
        clr     R10
        clr     R11
        clr     R12
        clr     R13
        clr     R14
        clr     R15
       

fetchloop:
        CALL    #fetch
        CALL    #decode
        CALL    #execute
        cmp.b   #3, progCount     ; testing...
        jeq $
        cmp.b   #16, progCount
        jeq $
        jmp     fetchloop
       



        //JMP $                           ; jump to current location '$'
                                        ; (endless loop)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


PORT1_ISR
        mov.w #500, debouncing
        mov.w debouncing, R5
        
next:   dec debouncing
        jnz next

        bit.b   #00000010b, &P1IFG      ; Test P1IFG to detect if there is
                                        ; an interrupt generated by P1.1
                                        ; that corresponds to push button S1
        jnz     P1int

        bit.b   #00000100b, &P1IFG

        jnz     P2int

        call    #endint ; TODO, this is adding another value to stack

P2int:
        bic.b   #00000110b, &P1IFG

        call    #clearDisplay

        cmp.b   #1, start
        jne     noStart
        mov.b   #1, begin
        reti

noStart:
        cmp.b   #1, counter
        jeq     displayNata

        cmp.b   #2, counter
        jeq     displayXavi

        cmp.b   #3, counter
        jeq     displayAngel

        cmp.b   #4, counter
        jeq     displayYani

        ;reti                            ;should never run

P1int:
        bic.b   #00000110b, &P1IFG      ; Clear interrupt flag and check

        cmp.b   #1, R4
        jeq     endint

        cmp.b   #1, begin
        jeq     endAll

        call    #clearDisplay

        mov.b   #10110111B, &0xA29
        mov.b   #11011011B, &0xA25
        mov.b   #10000000B, &0xA23
        mov.b   #01010000B, &0xA24
        mov.b   #11111100B, &0xA32
        mov.b   #10111111B, &0xA2E
        mov.b   #11111100B, &0xA27

        mov.b   #1, start
        mov.b   start, R6

      reti

endAll:
      reti

endint:

      mov.b     #0, R4
      call    #clearDisplay
      call    #cpurum
      reti

clearDisplay:

      mov.b     #0x00,&0xA29
      mov.b     #0x00,&0xA2A
      mov.b     #0x00,&0xA25
      mov.b     #0x00,&0xA26
      mov.b     #0x00,&0xA23
      mov.b     #0x00,&0xA24
      mov.b     #0x00,&0xA32
      mov.b     #0x00,&0xA33
      mov.b     #0x00,&0xA2E
      mov.b     #0x00,&0xA2F
      mov.b     #0x00,&0xA27
      mov.b     #0x00,&0xA28
      
      //battery
      mov.b     #0x00, &0xA31
      mov.b     #0x00, &0xA2D

      ret

displayNata:

      add.b     #1, counter

      call      #clearDisplay

      mov.b     #01101100B, &0xA29 ;N
      mov.b     #10000010B, &0xA2A
      mov.b     #11101111B, &0xA25 ;A
      mov.b     #10000000B, &0xA23 ;T
      mov.b     #01010000B, &0xA24
      mov.b     #11101111B, &0xA32 ;A
      mov.b     #00011100B, &0xA2E ;L
      mov.b     #10010000B, &0xA27 ;I
      mov.b     #01010000B, &0xA28

      nop
      nop
      nop
      nop

      reti

displayXavi:

      add.b     #1, counter

      call      #clearDisplay

      mov.b     #10101010B, &0xA2A ;X
      mov.b     #11101111B, &0xA25 ;A
      mov.b     #01111100B, &0xA23 ;V
      mov.b     #10010000B, &0xA32 ;I
      mov.b     #01010000B, &0xA33
      mov.b     #10011111B, &0xA2E ;E
      mov.b     #11001111B, &0xA27 ;R
      mov.b     #00000010B, &0xA28

      nop
      nop
      nop
      nop


      reti

displayAngel:

      add.b     #1, counter

      call      #clearDisplay

      mov.b     #11101111B, &0xA29 ;A
      mov.b     #01101100B, &0xA25 ;N
      mov.b     #10000010B, &0xA26
      mov.b     #10111101B, &0xA23 ;G
      mov.b     #10011111B, &0xA32 ;E
      mov.b     #00011100B, &0xA2E ;L
      mov.b     #11111100B, &0xA27 ;O

      nop
      nop
      nop
      nop

      reti

displayYani:

        mov.b   #1, counter

        call    #clearDisplay

        mov.b   #10110000B, &0xA2A ;Y
        mov.b   #11101111B, &0xA25 ;A
        mov.b   #01101100B, &0xA23 ;N
        mov.b   #10000010B, &0xA24
        mov.b   #10010000B, &0xA32 ;I
        mov.b   #01010000B, &0xA33
        mov.b   #10110111B, &0xA2E ;S
        mov.b   #01101111B, &0xA27 ;H

        nop
        nop
        nop
        nop

        reti

cpurum:

        mov.b    #10011100B, &0xA29 ;Create C
        mov.b    #11001111B, &0xA25 ;Create P
        mov.b    #01111100B, &0xA23 ;Create U
        mov.b    #11001111B, &0xA32 ;Create R
        mov.b    #00000010B, &0xA33 ;Complete R
        mov.b    #01111100B, &0xA2E ;Create U
        mov.b    #01101100B, &0xA27 ;Create M
        mov.b    #10100000B, &0xA28 ;Complete M

        ret


;instructionIn:
      ;mov.b #00000010B, &0xA22 ;Turn on R in LCD

; R10-R13 -> R0-R3 para CPURUM
; R8 Stores current instruction
; R9 stores address of function to run
; R5 For first function argument
; R6 for second (if applicable)

fetch:        ;TODO: progCount doesn't increment properly, consider replacing

        mov.b     progCount, R7   
        mov.b     cpuRAM(R7), R8       ;move instruction to R8 (IR)
        add       #1, progCount
        ret

decode:

          mov.w   R8, R5                   ; Load mask into register
          bic.b   #00111111b, R5           ; Test bits 15-14 of the opcode
          cmp.b   #00000000b, R5           ;clear to check the bit that indicate the instruction
          jeq     foundLoad
          cmp.b   #01000000b, R5
          jeq     foundStore
          cmp.b   #10000000b, R5
          jeq     foundAdd
          cmp.b   #11000000b, R5
          jeq     instruction11xx          ;para los bit de 11

instruction11xx:

          mov.w   R8, R5                   ; Load mask into register
          bic.b   #00001111b, R5           ;clear to check the bit that indicate the instruction
          cmp.b   #11100000b, R5
          jeq     foundOut
          cmp.b   #11110000b, R5
          jeq     found30
          cmp.b   #11000000b, R5
          jeq     instruction1100xx        ;brincar para las instrucciones de que son idicados con 6 bits

instruction1100xx:

          mov.w   R8, R5                   ; Load mask into register
          bic.b   #00000011b, R5           ;clear to check the bit that indicate the instruction
          cmp.b   #11000000b, R5
          jeq     foundNeg
          cmp.b   #11000100b, R5
          jeq     foundShr
          cmp.b   #11001100b, R5
          jeq     foundIn

foundLoad:                              ;load address data in reg
        mov.b   R8, R5
        mov.b   R8, R6
        bic.b   #11001111b, R5           ;first argument (register)
        bic.b   #11110000b, R6           ;second argument (address)
        mov     #load, R9
        jmp     exitDecode
foundStore:                             ;store reg value in address
        mov.b   R8, R5
        mov.b   R8, R6
        bic.b   #11001111b, R5           ;first arg (register)
        bic.b   #11110000b, R6           ;second arg (address)
        mov     #store, R9
        jmp     exitDecode
foundAdd:                               ;add two registers together
        mov.b   R8, R5
        mov.b   R8, R6
        bic.b   #11001111b, R5           ;first arg (register)
        bic.b   #11110011b, R6           ;second arg (register)
        mov     #addRegisters, R9
        jmp     exitDecode

foundNeg:                               ;negate one register
        mov.b   R8, R5
        bic.b   #11111100b, R5          ;first arg  (register)
        mov.w   #negate, R9
        jmp     exitDecode
foundShr:                               ;shift register right
        mov.b   R8, R5
        bic.b   #11111100b, R5          ;first arg (register)
        mov.w   #shiftRight, R9
        jmp     exitDecode
foundIn:
        mov.b   R8, R5
        bic.b   #11111100b, R5          ;first arg (register)
        mov     #recieveInput, R9
        jmp     exitDecode
foundOut:
        mov.b   R8, R5
        mov.b   R8, R6
        bic.b   #11110011b, R5
        bic.b   #11111100b, R6
        mov     #output, R9
        jmp     exitDecode
found30:
        mov.b   R8, R5
        bic.b   #11110000b, R5
        mov     #jumpIf30, R9
        jmp     exitDecode
exitDecode:
        ret


execute:                                ;always assume that instr in R8
        call    R9
endExecute:
        ret




;R5 -> Register
;R6 -> Address
load:
        cmp.b   #0x00, R5
        jeq     loadR0
        cmp.b   #0x10, R5
        jeq     loadR1
        cmp.b   #0x20, R5
        jeq     loadR2
        ;we don't need the last compare, means it'll be R3
        mov.b     cpuRAM(R6), R13
        jmp     endLoad
loadR0:                                 ;R0 is always 0
        clr     R10
        jmp     endLoad
loadR1:
        mov.b     cpuRAM(R6), R11
        jmp     endLoad
loadR2:
        mov.b     cpuRAM(R6), R12
endLoad:
        ret

;R5 -> Register
;R6 -> Address
store:
        cmp.b   #0x00, R5
        jeq     storeR0
        cmp.b   #0x10, R5
        jeq     storeR1
        cmp.b   #0x20, R5
        jeq     storeR2
        ;we don't need the last compare, means it'll be R3
        mov.b     R13, cpuRAM(R6)
        jmp     endStore
storeR0:
        mov.b     R10, cpuRAM(R6)
        jmp     endStore
storeR1:
        mov.b     R11, cpuRAM(R6)
        jmp     endStore
storeR2:
        mov.b     R12, cpuRAM(R6)
endStore:
        ret

;R5 -> destination register
;R6 -> Register to add
addRegisters:
        ;first determine which is destination register
        cmp.b   #0x00, R5
        jeq     addR0GetSS
        cmp.b   #0x10, R5
        jeq      addR1GetSS
        cmp.b   #0x20, R5
        jeq     addR2GetSS
        jmp     addR3GetSS
addR0GetSS:
        cmp.b   #0x00, R6
        jeq     addR0R0
        cmp.b   #0x04, R6
        jeq     addR0R1
        cmp.b   #0x08, R6
        jeq     addR0R2
        jmp     addR0R3
addR1GetSS:
        cmp.b   #0x00, R6
        jeq     addR1R0
        cmp.b   #0x04, R6
        jeq     addR1R1
        cmp.b   #0x08, R6
        jeq     addR1R2
        jmp     addR1R3
addR2GetSS:
        cmp.b   #0x00, R6
        jeq     addR2R0
        cmp.b   #0x04, R6
        jeq     addR2R1
        cmp.b   #0x08, R6
        jeq     addR2R2
        jmp     addR2R3
addR3GetSS:
        cmp.b   #0x00, R6
        jeq     addR3R0
        cmp.b   #0x04, R6
        jeq     addR3R1
        cmp.b   #0x08, R6
        jeq     addR3R2
        jmp     addR3R3
addR0R0:                        ;do nothing bc R0 is always 0
addR0R1:
addR0R2:
addR0R3:                        ;add src, dst
        clr     R10
        jmp     endAdd
addR1R0:
        add.b   R10, R11
        jmp     endAdd
addR1R1:
        add.b   R11, R11
        jmp     endAdd
addR1R2:
        add.b   R12, R11
        jmp     endAdd
addR1R3:
        add.b   R13, R11
        jmp     endAdd
addR2R0:
        add.b   R10, R12
        jmp     endAdd
addR2R1:
        add.b   R11, R12
        jmp     endAdd
addR2R2:
        add.b   R12, R12
        jmp     endAdd
addR2R3:
        add.b   R13, R12
        jmp     endAdd
addR3R0:
        add.b   R10, R13
        jmp     endAdd
addR3R1:
        add.b   R11, R13
        jmp     endAdd
addR3R2:
        add.b   R12, R13
        jmp     endAdd
addR3R3:
        add.b   R13, R13
endAdd:
        ret


recieveInput:
              mov.b   #00000010b, &0xA22
              cmp.b   #1, runningInDebugger
              jeq     readInput
              mov.w   #0, instCounter
              mov.w #62500, delayCounter
delay:
              dec delayCounter
              cmp #0, delayCounter
              jne delay
              inc instCounter
              mov.b &P1IN, R4
loopIn:       cmp.w   #5, instCounter
              jne delay
              call #readInput
              ret

readInput:
              mov.b &P1IN, R4
              rra R4

              cmp.b #00000001, R5
              jne notinputR1
              mov.b R4, R11
              mov.b #00000000b, &0xA22
              ret
notinputR1:   cmp.b #00000010, R5
              jne notinputR2
              mov.b R4, R12
              mov.b #00000000b, &0xA22
              ret
notinputR2:   cmp.b #00000011, R5
              jne notinputR3
              mov.b R4, R13
notinputR3:   mov.b #00000000b, &0xA22
              ret

jumpIf30:
        cmp     #0x0000, R13
        jeq     is30
        ret
is30:
        ;change progCount value to value in address
        bic.w   #0xFFF0, R8
        mov     R8, progCount
        ret

negate:
        cmp.b   #0x01, R5
        jeq     negateR1
        cmp.b   #0x02, R5
        jeq     negateR2
        cmp.b   #0x03, R5
        jeq     negateR3
        ret

negateR1:
        inv R11
        inc R11
        ret

negateR2:
        inv R13
        inc R13
        ret

negateR3:
        inv R13
        inc R13
        ret

shiftRight:
        cmp.b   #0x01, R5
        jeq     shiftRightR1
        cmp.b   #0x02, R5
        jeq     shiftRightR2
        cmp.b   #0x03, R5
        jeq     shiftRightR3
        ret

shiftRightR1:
        rra R11
        ret

shiftRightR2:
        rra R12
        ret

shiftRightR3:
        rra R13
        ret

output:
        cmp.b   #00000100b, R5
        jeq     outR1
        cmp.b   #00001000b, R5
        jeq     outR2
        cmp.b   #00001100b, R5
        jeq     outR3
        ret

outR1:
       mov.b R11, R15
       cmp.b #00000000b, R6
       jeq   outputHEX
       cmp.b #00000001b, R6
       jeq   outputBI
       cmp.b #00000010b, R6
       jeq   outputDEC

       ret

outR2:
       mov.b R12, R15
       cmp.b #00000000b, R6
       jeq   outputHEX
       cmp.b #00000001b, R6
       jeq   outputBI
       cmp.b #00000010b, R6
       jeq   outputDEC
       ret

outR3:
       mov.b R13, R15
       cmp.b #00000000b, R6
       jeq   outputHEX
       cmp.b #00000001b, R6
       jeq   outputBI
       cmp.b #00000010b, R6
       jeq   outputDEC
       ret

outputBI:

      call      #clearDisplay
      mov.b   #0 , R6    ; even positions
      mov.b   #0 , R14   ; odd positions

      mov.b   R15, R5
      bic.b   #11111110b, R5
      call    #checkeven1

      mov.b   R15, R5
      bic.b   #11111011b, R5
      call    #checkeven2

      mov.b   R15, R5
      bic.b   #11101111b, R5
      call    #checkeven3

      mov.b   R15, R5
      bic.b   #10111111b, R5
      call    #checkeven4

      mov.b   R15, R5
      bic.b   #11111101b, R5
      call    #checkodd1

      mov.b   R15, R5
      bic.b   #11110111b, R5
      call    #checkodd2

      mov.b   R15, R5
      bic.b   #11011111b, R5
      call    #checkodd3

      mov.b   R15, R5
      bic.b   #01111111b, R5
      call    #checkodd4

      mov.b   R14, &0xA31
      mov.b   R6, &0xA2D

      ret


checkeven1:
      cmp.b   #00000001b, R5
      jeq     addeven1
      ret
checkeven2:
      cmp.b   #00000100b, R5
      jeq     addeven2
      ret
checkeven3:
      cmp.b   #00010000b, R5
      jeq     addeven3
      ret
checkeven4:
      cmp.b   #01000000b, R5
      jeq     addeven4
      ret
checkodd1:
      cmp.b   #00000010b, R5
      jeq     addodd1
      ret
checkodd2:
      cmp.b   #00001000b, R5
      jeq     addodd2
      ret
checkodd3:
      cmp.b   #00100000b, R5
      jeq     addodd3
      ret
checkodd4:
      cmp.b   #10000000b, R5
      jeq     addodd4
      ret
addeven1:
      add.b #00010000b, R14
      ret
addeven2:
      add.b #10000000b, R14
      ret
addeven3:
      add.b #01000000b, R14
      ret
addeven4:
      add.b #00100000b, R14
      ret
addodd1:
      add.b #00010000b, R6
      ret
addodd2:
      add.b #10000000b, R6
      ret
addodd3:
      add.b #01000000b, R6
      ret
addodd4:
      add.b #00100000b, R14
      ret

outputHEX:

       call      #clearDisplay 
       mov.b   R15, R5
       mov.b   R15, R6
       bic.b   #11110000b, R5
       call    #hexRight
       bic.b   #00001111b,R6
       call    #hexLeft
       ret

hexRight:
       cmp.b   #00000000b,R5
       jeq     hexout0R
       cmp.b   #00000001b,R5
       jeq     hexout1R
       cmp.b   #00000010b,R5
       jeq     hexout2R
       cmp.b   #00000011b,R5
       jeq     hexout3R
       cmp.b   #00000100b,R5
       jeq     hexout4R
       cmp.b   #00000101b,R5
       jeq     hexout5R
       cmp.b   #00000110b,R5
       jeq     hexout6R
       cmp.b   #00000111b,R5
       jeq     hexout7R
       cmp.b   #00001000b,R5
       jeq     hexout8R
       cmp.b   #00001001b,R5
       jeq     hexout9R
       cmp.b   #00001010b,R5
       jeq     hexoutAR
       cmp.b   #00001011b,R5
       jeq     hexoutBR
       cmp.b   #00001100b,R5
       jeq     hexoutCR
       cmp.b   #00001101b,R5
       jeq     hexoutDR
       cmp.b   #00001110b,R5
       jeq     hexoutER
       cmp.b   #00001111b,R5
       jeq     hexoutFR


hexLeft:
       bic.b   #00001111b,R6
       cmp.b   #00000000b,R6
       jeq     hexout0L
       cmp.b   #00010000b,R6
       jeq     hexout1L
       cmp.b   #00100000b,R6
       jeq     hexout2L
       cmp.b   #00110000b,R6
       jeq     hexout3L
       cmp.b   #01000000b,R6
       jeq     hexout4L
       cmp.b   #01010000b,R6
       jeq     hexout5L
       cmp.b   #01100000b,R6
       jeq     hexout6L
       cmp.b   #01110000b,R6
       jeq     hexout7L
       cmp.b   #10000000b,R6
       jeq     hexout8L
       cmp.b   #10010000b,R6
       jeq     hexout9L
       cmp.b   #10100000b,R6
       jeq     hexoutAL
       cmp.b   #10110000b,R6
       jeq     hexoutBL
       cmp.b   #11000000b,R6
       jeq     hexoutCL
       cmp.b   #11010000b,R6
       jeq     hexoutDL
       cmp.b   #11100000b,R6
       jeq     hexoutEL
       cmp.b   #11110000b,R6
       jeq     hexoutFL


hexout0R:
     mov.b    #0xFC, &0xA27 ; DISPLAY 0
     ret
hexout1R:
     mov.b    #0x60, &0xA27 ; DISPLAY 1
     ret
hexout2R:
     mov.b    #0xDB, &0xA27 ; DISPLAY 2
     ret
hexout3R:
     mov.b    #0xF3, &0xA27 ; DISPLAY 3
     ret
hexout4R:
     mov.b    #0x67, &0xA27 ; DISPLAY 4
     ret
hexout5R:
     mov.b    #0xB7, &0xA27 ; DISPLAY 5
     ret
hexout6R:
     mov.b    #0xBF, &0xA27 ; DISPLAY 6
     ret
hexout7R:
     mov.b    #0xE4, &0xA27 ; DISPLAY 7
     ret
hexout8R:
     mov.b    #0xFF, &0xA27 ; DISPLAY 8
     ret
hexout9R:
     mov.b    #0xF7, &0xA27 ; DISPLAY 9
     ret
hexoutAR:
     mov.b    #0xEF, &0xA27 ; DISPLAY A
     ret
hexoutBR:
     mov.b    #0xF1, &0xA27 ; DISPLAY B
     mov.b    #0x50, &0xA28
     ret
hexoutCR:
     mov.b    #0x9C, &0xA27 ; DISPLAY C
     ret
hexoutDR:
     mov.b    #0xF0, &0xA27 ; DISPLAY D
     mov.b    #0x50, &0xA28
     ret
hexoutER:
     mov.b    #0x9E, &0xA27 ; DISPLAY E
     ret
hexoutFR:
     mov.b    #0x8E, &0xA27 ; DISPLAY F
     ret

hexout0L:
     mov.b    #0xFC, &0xA2E ; DISPLAY 0
     ret
hexout1L:
     mov.b    #0x60, &0xA2E ; DISPLAY 1
     ret
hexout2L:
     mov.b    #0xDB, &0xA2E ; DISPLAY 2
     ret
hexout3L:
     mov.b    #0xF3, &0xA2E ; DISPLAY 3
     ret
hexout4L:
     mov.b    #0x67, &0xA2E ; DISPLAY 4
     ret
hexout5L
     mov.b    #0xB7, &0xA2E ; DISPLAY 5
     ret
hexout6L:
     mov.b    #0xBF, &0xA2E ; DISPLAY 6
     ret
hexout7L:
     mov.b    #0xE4, &0xA2E ; DISPLAY 7
     ret
hexout8L:
     mov.b    #0xFF, &0xA2E ; DISPLAY 8
     ret
hexout9L:
     mov.b    #0xF7, &0xA2E ; DISPLAY 9
     ret
hexoutAL:
     mov.b    #0xEF, &0xA2E ; DISPLAY A
     ret
hexoutBL:
     mov.b    #0xF1, &0xA2E ; DISPLAY B
     mov.b    #0x50, &0xA2F
     ret
hexoutCL:
     mov.b    #0x9C, &0xA2E ; DISPLAY C
     ret
hexoutDL:
     mov.b    #0xF0, &0xA2E ; DISPLAY D
     mov.b    #0x50, &0xA2F
     ret
hexoutEL:
     mov.b    #0x9E, &0xA2E ; DISPLAY E
     ret
hexoutFL:
     mov.b    #0x8E, &0xA2E ; DISPLAY F
     ret

TIMER_A0_ISR:
    sub.b #00000001b, timeoftimer
    jeq timer0

    mov.b timeoftimer, R5
    
    call #mod10
    ; R5 has the mod (reminder) and R6 has the result (quoatient)
    call #printdigitdec1  ; from right to left

    mov.b R6, R5
    call #mod10
    ; R5 has the mod (reminder) and R6 has the result (quoatient)
    call #printdigitdec2

    mov.b R6, R5
    call #mod10
    ; R5 has the mod (reminder) and R6 has the result (quoatient)
    call #printdigitdec3
   
    reti

timer0:
    mov   #0, &TA0CCR0
    mov   #MC_0, &TA0CTL
    mov.b #0x00, R5
    call #decout1num0
    call #decout2num0
    call #decout3num0
    reti
    

outputDEC:
      ; R15 is the number to be displayed
      ; R6 for result
      ; R5 copy of result
      call      #clearDisplay
      mov.b R15, R5
      call #mod10
      ; R5 has the mod (reminder) and R6 has the result (quoatient)
      call #printdigitdec1  ; from right to left

      mov.b R6, R5
      call #mod10
      ; R5 has the mod (reminder) and R6 has the result (quoatient)
      call #printdigitdec2

      mov.b R6, R5
      call #mod10
      ; R5 has the mod (reminder) and R6 has the result (quoatient)
      call #printdigitdec3
      
      
      cmp.b #0, runningInDebugger
      jeq startTimer
      ret
      
startTimer:
     mov.b  R15, timeoftimer
     mov    #TASSEL_2+MC_1+ID_3, &TA0CTL
     nop
     mov    #12500, &TA0CCR0
     nop
     ret

mod10:
      ; R15 is the number to be displayed
      ; R6 for result
      ; R14 shift needed
       clr R6
       mov.b #10100000b, R14
       call #checkGE

       mov.b #01010000b, R14
       call #checkGE

       mov.b #00101000b, R14
       call #checkGE

       mov.b #00010100b, R14
       call #checkGE

       mov.b #00001010b, R14
       call #checkGE

       ret
       ; R5 is the result of the mod

checkGE:
     cmp.b R14, R5
     jhs greaterDiv
     jlo  lesserDiv

greaterDiv:
     sub.b R14, R5
     setc
     rlc R6
     ret
lesserDiv:
     clrc
     rlc R6
     ret

printdigitdec1:
       cmp.b   #00000000b,R5
       jeq     decout1num0
       cmp.b   #00000001b,R5
       jeq     decout1num1
       cmp.b   #00000010b,R5
       jeq     decout1num2
       cmp.b   #00000011b,R5
       jeq     decout1num3
       cmp.b   #00000100b,R5
       jeq     decout1num4
       cmp.b   #00000101b,R5
       jeq     decout1num5
       cmp.b   #00000110b,R5
       jeq     decout1num6
       cmp.b   #00000111b,R5
       jeq     decout1num7
       cmp.b   #00001000b,R5
       jeq     decout1num8
       cmp.b   #00001001b,R5
       jeq     decout1num9

printdigitdec2:
       cmp.b   #00000000b,R5
       jeq     decout2num0
       cmp.b   #00000001b,R5
       jeq     decout2num1
       cmp.b   #00000010b,R5
       jeq     decout2num2
       cmp.b   #00000011b,R5
       jeq     decout2num3
       cmp.b   #00000100b,R5
       jeq     decout2num4
       cmp.b   #00000101b,R5
       jeq     decout2num5
       cmp.b   #00000110b,R5
       jeq     decout2num6
       cmp.b   #00000111b,R5
       jeq     decout2num7
       cmp.b   #00001000b,R5
       jeq     decout2num8
       cmp.b   #00001001b,R5
       jeq     decout2num9

printdigitdec3:
       cmp.b   #00000000b,R5
       jeq     decout3num0
       cmp.b   #00000001b,R5
       jeq     decout3num1
       cmp.b   #00000010b,R5
       jeq     decout3num2
       cmp.b   #00000011b,R5
       jeq     decout3num3
       cmp.b   #00000100b,R5
       jeq     decout3num4
       cmp.b   #00000101b,R5
       jeq     decout3num5
       cmp.b   #00000110b,R5
       jeq     decout3num6
       cmp.b   #00000111b,R5
       jeq     decout3num7
       cmp.b   #00001000b,R5
       jeq     decout3num8
       cmp.b   #00001001b,R5
       jeq     decout3num9

decout1num0:
     mov.b    #0xFC, &0xA23 ; DISPLAY 0
     ret
decout1num1:
     mov.b    #0x60, &0xA23 ; DISPLAY 0
     ret
decout1num2:
     mov.b    #0xDB, &0xA23 ; DISPLAY 0
     ret
decout1num3:
     mov.b    #0xF3, &0xA23 ; DISPLAY 0
     ret
decout1num4:
     mov.b    #0x67, &0xA23 ; DISPLAY 0
     ret
decout1num5:
     mov.b    #0xB7, &0xA23 ; DISPLAY 0
     ret
decout1num6:
     mov.b    #0xBF, &0xA23 ; DISPLAY 0
     ret
decout1num7:
     mov.b    #0xE4, &0xA23 ; DISPLAY 0
     ret
decout1num8:
     mov.b    #0xFF, &0xA23 ; DISPLAY 0
     ret
decout1num9:
     mov.b    #0xF7, &0xA23 ; DISPLAY 0
     ret

decout2num0:
     mov.b    #0xFC, &0xA25 ; DISPLAY 0
     mov.b    #0x01, &0xA26 ; POINT
     ret
decout2num1:
     mov.b    #0x60, &0xA25 ; DISPLAY 0
     mov.b    #0x01, &0xA26 ; POINT
     ret
decout2num2:
     mov.b    #0xDB, &0xA25 ; DISPLAY 0
     mov.b    #0x01, &0xA26 ; POINT
     ret
decout2num3:
     mov.b    #0xF3, &0xA25 ; DISPLAY 0
     mov.b    #0x01, &0xA26 ; POINT
     ret
decout2num4:
     mov.b    #0x67, &0xA25 ; DISPLAY 0
     mov.b    #0x01, &0xA26 ; POINT
     ret
decout2num5:
     mov.b    #0xB7, &0xA25 ; DISPLAY 0
     mov.b    #0x01, &0xA26 ; POINT
     ret
decout2num6:
     mov.b    #0xBF, &0xA25 ; DISPLAY 0
     mov.b    #0x01, &0xA26 ; POINT
     ret
decout2num7:
     mov.b    #0xE4, &0xA25 ; DISPLAY 0
     mov.b    #0x01, &0xA26 ; POINT
     ret
decout2num8:
     mov.b    #0xFF, &0xA25 ; DISPLAY 0
     mov.b    #0x01, &0xA26 ; POINT
     ret
decout2num9:
     mov.b    #0xF7, &0xA25 ; DISPLAY 0
     mov.b    #0x01, &0xA26 ; POINT
     ret

decout3num0:
     mov.b    #0xFC, &0xA29 ; DISPLAY 0
     ret
decout3num1:
     mov.b    #0x60, &0xA29 ; DISPLAY 0
     ret
decout3num2:
     mov.b    #0xDB, &0xA29 ; DISPLAY 0
     ret
decout3num3:
     mov.b    #0xF3, &0xA29 ; DISPLAY 0
     ret
decout3num4:
     mov.b    #0x67, &0xA29 ; DISPLAY 0
     ret
decout3num5:
     mov.b    #0xB7, &0xA29 ; DISPLAY 0
     ret
decout3num6:
     mov.b    #0xBF, &0xA29 ; DISPLAY 0
     ret
decout3num7:
     mov.b    #0xE4, &0xA29 ; DISPLAY 0
     ret
decout3num8:
     mov.b    #0xFF, &0xA29 ; DISPLAY 0
     ret
decout3num9:
     mov.b    #0xF7, &0xA29 ; DISPLAY 0
     ret

     END
