#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    TIMER_A0_ISR            ; set vector for 'TIMER_A0_ISR' routine

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        DC16    PORT1_ISR               ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).

;placing CPURUM Ram at beginning of actual RAM
; Primeros 16 bytes son RAM de CPURUM
        ORG     0x01C00
cpuRAM  ;     INSTRUCTIONS USED TO TEST DECODING
        ; TODO: Cuando movemos valores a registro, padding ocurre por ser 16 bits
        db      0xff, 0x3f, 0x6f, 0x9f, 0xc3, 0xc5, 0xcf, 0xd6, 0xff, 9, 10, 0, 0, 0, 0
runningInDebugger 
        db      0
progCount
        db      0                       ;testing
instructionMasks                        ; first 6 bits to AND with and get opcode 
        db      0

start   db      0

begin   db      0

counter db      1

p1counter db    1

debouncing db 500

instCounter dw 0

instrIn db 0

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack


UnlockGPIO:
        bic.w   #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on default
                                        ; high-impedance mode to activate
                                        ; previously configured port settings

	;Initialize LCD_C
    	;ACLK, Divider = 1, Pre-divider = 16; 4-pin MUX
	MOV.W   #0x041e,&LCDCCTL0

    	;VLCD generated internally,
    	;V2-V4 generated internally, v5 to ground
    	;Set VLCD voltage to 2.60v
    	;Enable charge pump and select internal reference for it
    	MOV.W   #0x0208,&LCDCVCTL

	MOV.W   #0x8000,&LCDCCPCTL   ;Clock synchronization enabled

	MOV.W   #2,&LCDCMEMCTL       ;Clear LCD memory

        ;Initialize LCD segments 0 - 21; 26 - 43
        MOV.W   #0xFFFF,&LCDCPCTL0
	MOV.W   #0xfc3f,&LCDCPCTL1
    	MOV.W   #0x0fff,&LCDCPCTL2
        

	;Turn LCD on
	BIS.W   #1,&LCDCCTL0
        
        ;Turn on baterry LCD
        mov.b   #0xFF, &0xA31
        mov.b   #0xFF, &0xA2D
        
        mov     #CCIE, &TA0CCTL0        ; Enable TACCR0 interrupt
        mov     #TASSEL_2+MC_1+ID_3, &TA0CTL  ;Set timer according to next table
        mov     #62500, &TA0CCR0   
        
	nop
        ; Uses SMCLK and up mode
        ; TASSELx        MCx (mode control)                IDx (input divider)
        ; 00 -> TACLK    00 -> Stop                        00 -> /1
        ; 01 -> ACLK     01 -> Up mode (up to TACCR0)      01 -> /2
        ; 10 -> SMCLK    10 -> Continuous (up to 0FFFFh)   02 -> /4
        ; 11 -> INCLK    11 -> Up/down (top on TACCR0)     03 -> /8

        ; period = cycles * divider / SMLCK
        ; Assuming SMLCK = 1 MHz, divider = 8 and period = 0.5 seg
        ; cycles = 62500.  With period = 0.5 LED turn on every 1 second
        ;mov     #62500, &TA0CCR0        ; Set the timer capture compare register 0
        
//        bic.b   #00000010b, &P1IFG    ; To erase a flag raised before
                                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.

        nop                             ; NOP before setting GIE required by
                                        ; the architecture
        bis.w   #GIE,SR 	        ; Interrupts enabled (same as eint)
                                        ; so that the micro reacts to 
                                        ; interrupts
        nop
        ;bis     #GIE+LPM0, SR
        nop                             ; Wait after setting interrupt bit

;        bis     #LPM0,SR                ; Enter Low Power Mode 0
        nop
        

main:   NOP                             ; main program

        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer
        
        call    #clearDisplay
        call    #cpurum

        bic.b   #0xFF,&P1SEL0           ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1           ; Digital I/O is the default
        bic.b   #0xFF,&P9SEL0
        bic.b   #0xFF,&P9SEL1

        mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for output

        bis.b   #0xFF,&P9DIR            ; Set all P9 pins for output

        mov.b   #00000110B, &P1REN            ; P1.1 Resistor enabled as pullup
        bis.b   #00000110B, &P1OUT            ; resistor because pushing button
                                        ; connects it to ground

        bic.b #0x01, &P1OUT
        bic.b #0x80, &P9OUT

        bis.b   #00000110B, &P1IE             ; Enable interrupt at P1.1
        bis.b   #02h, &P1IES            ; Set interrupt on high-to-low 
                                        ; transition of P1.1
        ;mov.b &P1IN, R4
        
        mov.b #0, instCounter
        
        cmp.b #1, runningInDebugger
        jeq startProgram
        
loopover:                               ; stuck in looping names
        cmp.b   #1, begin     
        jne     loopover

startProgram:
        bic.b   #00000110B, &P1IE
        bic.b   #02h, &P1IES
        
        nop
        ;bis     #GIE+LPM0, SR
        ;nop

        mov.b #00000001B, R5
        call #recieveInput
        
        ;start executing instructions from ram
        MOV.W   #cpuRAM, R7             ; guardar pointer a principio de RAM

        clr     R8 
        clr     R9
        clr     R10
        clr     R11
        clr     R12
        clr     R13

        CALL    #fetch
        CALL    #decode
        CALL    #execute
        ; will place function pointer in R9        
        ;execute instruction stored in R9 after decode
        


        
        JMP $                           ; jump to current location '$'
                                        ; (endless loop)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

TIMER_A0_ISR:
        xor.b #BIT7, P9OUT
        mov.b instCounter, R13
        
        cmp #5, instCounter
        jnz noToggle
        
        mov #0, instCounter
        ;mov.b instCounter, R4

        cmp.b #1, instrIn
        jeq readInput
        
        reti
        
noToggle:
        ;mov.b instCounter, R4
        inc instCounter
fin:
        ;xor 	#CCIE, &TA0CCTL0
        reti

PORT1_ISR
        mov #500, debouncing
next:   dec.b debouncing
        jnz next
        
        bit.b   #00000010b, &P1IFG      ; Test P1IFG to detect if there is
                                        ; an interrupt generated by P1.1
                                        ; that corresponds to push button S1
        jnz     P1int                                
        
        bit.b   #00000100b, &P1IFG
        
        jnz     P2int
        
        call    #endint ; TODO, this is adding another value to stack
      
P2int:
        bic.b   #00000110b, &P1IFG
        
        call    #clearDisplay
        
        cmp.b   #1, start
        jne     noStart
        mov.b   #1, begin
        reti
        
noStart:  
        cmp.b   #1, counter
        jeq     displayNata
          
        cmp.b   #2, counter
        jeq     displayXavi
          
        cmp.b   #3, counter
        jeq     displayAngel
          
        cmp.b   #4, counter
        jeq     displayYani
        
        ;reti                            ;should never run 
        
P1int:  
        bic.b   #00000110b, &P1IFG      ; Clear interrupt flag and check

        cmp.b   #1, p1counter
        jeq     endint
        
        cmp.b   #1, begin
        jeq     endint
        
        call    #clearDisplay
        
        mov.b   #10110111B, &0xA29
        mov.b   #11011011B, &0xA25
        mov.b   #10000000B, &0xA23
        mov.b   #01010000B, &0xA24
        mov.b   #11111100B, &0xA32
        mov.b   #10111111B, &0xA2E
        mov.b   #11111100B, &0xA27
        
        mov.b   #1, start
        mov.b   start, R6
        
        reti    
        
endint:
      
      mov.b     #0, p1counter

      reti
      
clearDisplay:
 
      mov.b     #0x00,&0xA29
      mov.b     #0x00,&0xA2A
      mov.b     #0x00,&0xA25
      mov.b     #0x00,&0xA26
      mov.b     #0x00,&0xA23
      mov.b     #0x00,&0xA24
      mov.b     #0x00,&0xA32
      mov.b     #0x00,&0xA33
      mov.b     #0x00,&0xA2E
      mov.b     #0x00,&0xA2F
      mov.b     #0x00,&0xA27
      mov.b     #0x00,&0xA28
      
      ret

displayNata:
 
      add.b     #1, counter
      
      call      #clearDisplay
      
      mov.b     #01101100B, &0xA29 ;N
      mov.b     #10000010B, &0xA2A
      mov.b     #11101111B, &0xA25 ;A
      mov.b     #10000000B, &0xA23 ;T
      mov.b     #01010000B, &0xA24
      mov.b     #11101111B, &0xA32 ;A
      mov.b     #00011100B, &0xA2E ;L
      mov.b     #10010000B, &0xA27 ;I
      mov.b     #01010000B, &0xA28
      
      nop
      nop
      nop
      nop
      
      reti
      
displayXavi:

      add.b     #1, counter
      
      call      #clearDisplay
      
      mov.b     #10101010B, &0xA2A ;X
      mov.b     #11101111B, &0xA25 ;A
      mov.b     #01111100B, &0xA23 ;V
      mov.b     #10010000B, &0xA32 ;I
      mov.b     #01010000B, &0xA33
      mov.b     #10011111B, &0xA2E ;E
      mov.b     #11001111B, &0xA27 ;R
      mov.b     #00000010B, &0xA28
      
      nop
      nop
      nop
      nop
      
      
      reti
      
displayAngel:
      
      add.b     #1, counter
      
      call      #clearDisplay
      
      mov.b     #11101111B, &0xA29 ;A
      mov.b     #01101100B, &0xA25 ;N
      mov.b     #10000010B, &0xA26
      mov.b     #10111111B, &0xA23 ;G
      mov.b     #10011111B, &0xA32 ;E
      mov.b     #00011100B, &0xA2E ;L
      mov.b     #11111100B, &0xA27 ;O

      nop
      nop
      nop
      nop
      
      reti
      
displayYani:

        mov.b   #1, counter
      
        call    #clearDisplay
      
        mov.b   #10110000B, &0xA2A ;Y
        mov.b   #11101111B, &0xA25 ;A
        mov.b   #01101100B, &0xA23 ;N
        mov.b   #10000010B, &0xA24
        mov.b   #10010000B, &0xA32 ;I
        mov.b   #01010000B, &0xA33
        mov.b   #10110111B, &0xA2E ;S
        mov.b   #01101111B, &0xA27 ;H

        nop
        nop
        nop
        nop
      
        reti

cpurum:
     
        mov.b    #10011100B, &0xA29 ;Create C
        mov.b    #11001111B, &0xA25 ;Create P
        mov.b    #01111100B, &0xA23 ;Create U
        mov.b    #11001111B, &0xA32 ;Create R
        mov.b    #00000010B, &0xA33 ;Complete R
        mov.b    #01111100B, &0xA2E ;Create U
        mov.b    #01101100B, &0xA27 ;Create M
        mov.b    #10100000B, &0xA28 ;Complete M
      
        ret
      
      
;instructionIn:
      ;mov.b #00000010B, &0xA22 ;Turn on R in LCD

; R10-R13 -> R0-R3 para CPURUM
; R8 Stores current instruction 
; R9 stores address of function to run
; R5 For first function argument  
; R6 for second (if applicable) 

fetch:        ;TODO: progCount doesn't increment properly, consider replacing

        mov.b   progCount(R7), R8       ;move instruction to R8 (IR) 
        add     #1, progCount                   
        
        ret
        
                                        
decode:                                 ;decode by adding total
        jmp     found30                 ;basura, only for TESTING                 
        cmp     #0x00, R8               ;basura
        jeq     foundLoad
foundLoad:                              ;load address data in reg
        mov.b   R8, R5
        mov.b   R8, R6 
        bic.b   #11001111b, R5           ;first argument (register) 
        bic.b   #11110000b, R6           ;second argument (address)
        mov     #load, R9
        jmp     exitDecode
foundStore:                             ;store reg value in address
        mov.b   R8, R5 
        mov.b   R8, R6
        bic.b   #11001111b, R5           ;first arg (register)
        bic.b   #11110000b, R6           ;second arg (address) 
        mov     #store, R9
        jmp     exitDecode
foundAdd:                               ;add two registers together
        mov.b   R8, R5 
        mov.b   R8, R6
        bic.b   #11001111b, R5           ;first arg (register)
        bic.b   #11110011b, R6           ;second arg (register) 
        mov     #addRegisters, R9
        jmp     exitDecode

foundNeg:                               ;negate one register
        mov.b   R8, R5
        bic.b   #11111100b, R5          ;first arg  (register)
        mov     #negate, R9
        jmp     exitDecode
foundShr:                               ;shift register right
        mov.b   R8, R5 
        bic.b   #11111100b, R5          ;first arg (register)
        mov     #shiftRight, R9
        jmp     exitDecode
foundIn:
        mov.b   R8, R5 
        bic.b   #11111100b, R5          ;first arg (register)
        mov     #recieveInput, R9
        jmp     exitDecode
foundOut:
        mov.b   R8, R5 
        mov.b   R8, R6
        bic.b   #11110011b, R5 
        bic.b   #11111100b, R6 
        mov     #output, R9
        jmp     exitDecode
found30:
        mov.b   R8, R5 
        bic.b   #11110000b, R5
        mov     #jumpIf30, R9
        jmp     exitDecode
exitDecode:
        ret


execute:                                ;always assume that instr in R8

        call    R9
endExecute:
        ret 
        
        
        
        
;R5 -> Register
;R6 -> Address  
load:
        cmp.b   #0x00, R5
        jeq     loadR0
        cmp.b   #0x10, R5 
        jeq     loadR1 
        cmp.b   #0x20, R5
        jeq     loadR2
        ;we don't need the last compare, means it'll be R3
        mov     cpuRAM(R6), R13
        jmp     endLoad
loadR0:                                 ;R0 is always 0
        clr     R10
        jmp     endLoad
loadR1:
        mov     cpuRAM(R6), R11
        jmp     endLoad
loadR2:
        mov     cpuRAM(R6), R12
endLoad:
        ret
        
;R5 -> Register
;R6 -> Address         
store:
        cmp.b   #0x00, R5
        jeq     storeR0
        cmp.b   #0x10, R5 
        jeq     storeR1 
        cmp.b   #0x20, R5
        jeq     storeR2
        ;we don't need the last compare, means it'll be R3
        mov     R13, cpuRAM(R6)
        jmp     endStore
storeR0:
        mov     R10, cpuRAM(R6)
        jmp     endStore
storeR1:
        mov     R11, cpuRAM(R6) 
        jmp     endStore
storeR2:
        mov     R12, cpuRAM(R6) 
endStore:
        ret
        
;R5 -> destination register
;R6 -> Register to add
addRegisters:
        ;first determine which is destination register
        cmp.b   #0x00, R5
        jeq     addR0GetSS
        cmp.b   #0x10, R5 
        jeq      addR1GetSS
        cmp.b   #0x20, R5
        jeq     addR2GetSS
        jmp     addR3GetSS
addR0GetSS:
        cmp.b   #0x00, R6
        jeq     addR0R0
        cmp.b   #0x04, R6
        jeq     addR0R1
        cmp.b   #0x08, R6 
        jeq     addR0R2 
        jmp     addR0R3
addR1GetSS:
        cmp.b   #0x00, R6
        jeq     addR1R0
        cmp.b   #0x04, R6
        jeq     addR1R1
        cmp.b   #0x08, R6 
        jeq     addR1R2 
        jmp     addR1R3
addR2GetSS:
        cmp.b   #0x00, R6
        jeq     addR2R0
        cmp.b   #0x04, R6
        jeq     addR2R1
        cmp.b   #0x08, R6 
        jeq     addR2R2 
        jmp     addR2R3
addR3GetSS:
        cmp.b   #0x00, R6
        jeq     addR3R0
        cmp.b   #0x04, R6
        jeq     addR3R1
        cmp.b   #0x08, R6 
        jeq     addR3R2 
        jmp     addR3R3
addR0R0:                        ;do nothing bc R0 is always 0
addR0R1:
addR0R2:
addR0R3:                        ;add src, dst
        clr     R10 
        jmp     endAdd
addR1R0:
        add.b   R10, R11 
        jmp     endAdd
addR1R1:
        add.b   R11, R11 
        jmp     endAdd
addR1R2:
        add.b   R12, R11 
        jmp     endAdd      
addR1R3:
        add.b   R13, R11 
        jmp     endAdd
addR2R0:
        add.b   R10, R12 
        jmp     endAdd
addR2R1:
        add.b   R11, R12 
        jmp     endAdd
addR2R2:
        add.b   R12, R12 
        jmp     endAdd
addR2R3:
        add.b   R13, R12 
        jmp     endAdd
addR3R0:
        add.b   R10, R13 
        jmp     endAdd
addR3R1:
        add.b   R11, R13 
        jmp     endAdd
addR3R2:
        add.b   R12, R13 
        jmp     endAdd
addR3R3:
        add.b   R13, R13 
endAdd:
        ret

recieveInput: 
              mov.b   #00000010b, &0xA22
              cmp.b   #1, runningInDebugger
              jeq     readInput
              mov.b   #1, instrIn
              mov.b   #0, instCounter
loopIn:       cmp.b   #0, instrIn
              jne loopIn
              ret
        
readInput:    ;mov.b #00000001b, R5
              xor   #CCIE, &TA0CCTL0
              mov.b #0, instrIn
              mov.b &P1IN, R4
              and.b #00000110B, R4
              cmp.b #00000000B, R4
              jne verifyP1
              mov.b #00000011B, R4
verifyP1:     cmp.b #00000100B, R4
              jne verifyP2
              mov.b #00000001B, R4
verifyP2:     cmp.b #00000010B, R4
              jne noInput
              mov.b #00000010B, R4
              
noInput:      cmp.b #00000001, R5
              jne notinputR1
              mov.b R4, R11
              mov.b #00000000b, &0xA22
              reti
notinputR1:   cmp.b #00000010, R5
              jne notinputR2
              mov.b R4, R12
              mov.b #00000000b, &0xA22
              reti   
notinputR2:   cmp.b #00000011, R5
              jne notinputR3
              mov.b R4, R13
notinputR3:   mov.b #00000000b, &0xA22
              ret
              
jumpIf30:
        cmp     #0x0000, R13        
        jeq     is30
        ret
is30:
        ;change progcount value to value in address
        bic.w   #0xFFF0, R8 
        mov     R8, progCount
        ret
        END
  
negate:
        cmp.b   #0x01, R5
        jeq     negateR1
        cmp.b   #0x02, R5
        jeq     negateR2
        cmp.b   #0x03, R5
        jeq     negateR3
        ret
        
negateR1:
        inv R11
        inc R11
        ret
        
negateR2:
        inv R13
        inc R13
        ret
        
negateR3:
        inv R13
        inc R13
        ret
        
shiftRight:       
        cmp.b   #0x01, R5
        jeq     shiftRightR1
        cmp.b   #0x02, R5
        jeq     shiftRightR2
        cmp.b   #0x03, R5
        jeq     shiftRightR3:
        ret       
        
shiftRightR1:
        rra R11
        ret
        
shiftRightR2:
        rra R12
        ret
        
shiftRightR3:
        rra R13
        ret

output: 

//mov 0xFC,  /* "0" */
//mov 0x60,  /* "1" */
//mov 0xDB,  /* "2" */
//mov 0xF3,  /* "3" */
//mov 0x67,  /* "4" */
//mov 0xB7,  /* "5" */
//mov 0xBF,  /* "6" */
//mov 0xE4,  /* "7" */
//mov 0xFF,  /* "8" */
//mov 0xF7   /* "9" */
        
        add #0x20, R14
        mov.b @R[ss], &r14
        ret

