#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        DC16    PORT1_ISR               ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).

;placing CPURUM Ram at beginning of actual RAM
; Primeros 16 bytes son RAM de CPURUM
        ORG     0x01C00
cpuRAM  ;     INSTRUCTIONS USED TO TEST DECODING
        ; TODO: Cuando movemos valores a registro, padding ocurre por ser 16 bits
        db      0xff, 0x3f, 0x6f, 0x9f, 0xc3, 0xc5, 0xcf, 0xd6, 0xff, 9, 10, 0, 0, 0, 0
runningInDebugger 
        db      0
progCount
        db      0                       ;testing
instructionMasks                        ; first 6 bits to AND with and get opcode 
        db      0

start   db      0

begin   db      0

counter db      1

p1counter db    1

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack


UnlockGPIO:
        bic.w   #LOCKLPM5,&PM5CTL0      ; Disable the GPIO power-on default
                                        ; high-impedance mode to activate
                                        ; previously configured port settings

	;Initialize LCD_C
    	;ACLK, Divider = 1, Pre-divider = 16; 4-pin MUX
	MOV.W   #0x041e,&LCDCCTL0

    	;VLCD generated internally,
    	;V2-V4 generated internally, v5 to ground
    	;Set VLCD voltage to 2.60v
    	;Enable charge pump and select internal reference for it
    	MOV.W   #0x0208,&LCDCVCTL

	MOV.W   #0x8000,&LCDCCPCTL   ;Clock synchronization enabled

	MOV.W   #2,&LCDCMEMCTL       ;Clear LCD memory

        ;Initialize LCD segments 0 - 21; 26 - 43
        MOV.W   #0xFFFF,&LCDCPCTL0
	MOV.W   #0xfc3f,&LCDCPCTL1
    	MOV.W   #0x0fff,&LCDCPCTL2
        

	;Turn LCD on
	BIS.W   #1,&LCDCCTL0
        
        ;Turn on baterry LCD
        mov.b   #0xFF, &0xA31
        mov.b   #0xFF, &0xA2D
        
//        bic.b   #00000010b, &P1IFG    ; To erase a flag raised before
                                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.

        nop                             ; NOP before setting GIE required by
                                        ; the architecture
        bis.w   #GIE,SR 	        ; Interrupts enabled (same as eint)
                                        ; so that the micro reacts to 
                                        ; interrupts
        nop                             ; Wait after setting interrupt bit

;        bis     #LPM0,SR                ; Enter Low Power Mode 0
        nop
        

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer
        
        call    #clearDisplay
        call    #cpurum

        bic.b   #0xFF,&P1SEL0           ; Set PxSel0 and PxSel1 to digital I/O
        bic.b   #0xFF,&P1SEL1           ; Digital I/O is the default
        bic.b   #0xFF,&P9SEL0
        bic.b   #0xFF,&P9SEL1

        mov.b   #11111001B,&P1DIR       ; Set P1.1 and P1.2 for input and all
                                        ; other P1 pins for output

        bis.b   #0xFF,&P9DIR            ; Set all P9 pins for output

        mov.b   #00000110B, &P1REN            ; P1.1 Resistor enabled as pullup
        bis.b   #00000110B, &P1OUT            ; resistor because pushing button
                                        ; connects it to ground
        bis.b   #00000110B, &P1IE             ; Enable interrupt at P1.1
        bis.b   #02h, &P1IES            ; Set interrupt on high-to-low 
                                        ; transition of P1.1

        
loopover:                               ; stuck in looping names
        cmp.b   #1, begin     
        mov.b   begin, R7
        jne     loopover
        
        ;start executing instructions from ram
        MOV.W   #cpuRAM, R7             ; guardar pointer a principio de RAM

        clr     R8 
        clr     R9
        clr     R10
        clr     R11
        clr     R12
        clr     R13

        CALL    #fetch
        CALL    #decode
        CALL    #execute
        ; will place function pointer in R9        
        ;execute instruction stored in R9 after decode
        


        
        JMP $                           ; jump to current location '$'
                                        ; (endless loop)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PORT1_ISR
        bit.b   #00000010b, &P1IFG      ; Test P1IFG to detect if there is
                                        ; an interrupt generated by P1.1
                                        ; that corresponds to push button S1
        jnz     P1int                                
        
        bit.b   #00000100b, &P1IFG
        
        jnz     P2int
        
        call    #endint ; TODO, this is adding another value to stack
      
P2int:

        bic.b   #00000110b, &P1IFG
        
        call    #clearDisplay
        
        cmp.b   #1, start
        jne     noStart
        mov.b   #1, begin
        mov.b   begin, R7
        reti
        
noStart:  
        cmp.b   #1, counter
        jeq     displayNata
          
        cmp.b   #2, counter
        jeq     displayXavi
          
        cmp.b   #3, counter
        jeq     displayAngel
          
        cmp.b   #4, counter
        jeq     displayYani
        
        reti                            ;should never run 
        
P1int:
      
        bic.b   #00000110b, &P1IFG      ; Clear interrupt flag and check

        cmp.b   #1, p1counter
        jeq     endint
        
        call    #clearDisplay
        
        mov.b   #10110111B, &0xA29
        mov.b   #11011011B, &0xA25
        mov.b   #10000000B, &0xA23
        mov.b   #01010000B, &0xA24
        mov.b   #11111100B, &0xA32
        mov.b   #10111111B, &0xA2E
        mov.b   #11111100B, &0xA27
        
        mov.b   #1, start
        mov.b   start, R6
        
        reti
        
        
endint:
      
      mov.b     #0, p1counter

      reti
      
clearDisplay:
 
      mov.b     #0x00,&0xA29
      mov.b     #0x00,&0xA2A
      mov.b     #0x00,&0xA25
      mov.b     #0x00,&0xA26
      mov.b     #0x00,&0xA23
      mov.b     #0x00,&0xA24
      mov.b     #0x00,&0xA32
      mov.b     #0x00,&0xA33
      mov.b     #0x00,&0xA2E
      mov.b     #0x00,&0xA2F
      mov.b     #0x00,&0xA27
      mov.b     #0x00,&0xA28
      
      ret
      
 displayNata:
 
      add.b     #1, counter
      
      call      #clearDisplay
      
      mov.b     #01101100B, &0xA29 ;N
      mov.b     #10000010B, &0xA2A
      mov.b     #11101111B, &0xA25 ;A
      mov.b     #10000000B, &0xA23 ;T
      mov.b     #01010000B, &0xA24
      mov.b     #11101111B, &0xA32 ;A
      mov.b     #00011100B, &0xA2E ;L
      mov.b     #10010000B, &0xA27 ;I
      mov.b     #01010000B, &0xA28
      
      nop
      nop
      nop
      nop
      
      reti
      
displayXavi:

      add.b     #1, counter
      
      call      #clearDisplay
      
      mov.b     #10101010B, &0xA2A ;X
      mov.b     #11101111B, &0xA25 ;A
      mov.b     #01111100B, &0xA23 ;V
      mov.b     #10010000B, &0xA32 ;I
      mov.b     #01010000B, &0xA33
      mov.b     #10011111B, &0xA2E ;E
      mov.b     #11001111B, &0xA27 ;R
      mov.b     #00000010B, &0xA28
      
      nop
      nop
      nop
      nop
      
      
      reti
      
displayAngel:
      
      add.b     #1, counter
      
      call      #clearDisplay
      
      mov.b     #11101111B, &0xA29 ;A
      mov.b     #01101100B, &0xA25 ;N
      mov.b     #10000010B, &0xA26
      mov.b     #10111111B, &0xA23 ;G
      mov.b     #10011111B, &0xA32 ;E
      mov.b     #00011100B, &0xA2E ;L
      mov.b     #11111100B, &0xA27 ;O

      nop
      nop
      nop
      nop
      
      reti
      
displayYani:

        mov.b   #1, counter
      
        call    #clearDisplay
      
        mov.b   #10110000B, &0xA2A ;Y
        mov.b   #11101111B, &0xA25 ;A
        mov.b   #01101100B, &0xA23 ;N
        mov.b   #10000010B, &0xA24
        mov.b   #10010000B, &0xA32 ;I
        mov.b   #01010000B, &0xA33
        mov.b   #10110111B, &0xA2E ;S
        mov.b   #01101111B, &0xA27 ;H

        nop
        nop
        nop
        nop
      
        reti

cpurum:
     
        mov.b    #10011100B, &0xA29 ;Create C
        mov.b    #11001111B, &0xA25 ;Create P
        mov.b    #01111100B, &0xA23 ;Create U
        mov.b    #11001111B, &0xA32 ;Create R
        mov.b    #00000010B, &0xA33 ;Complete R
        mov.b    #01111100B, &0xA2E ;Create U
        mov.b    #01101100B, &0xA27 ;Create M
        mov.b    #10100000B, &0xA28 ;Complete M
      
        ret
      
      
;instructionIn:
      ;mov.b #00000010B, &0xA22 ;Turn on R in LCD

; R10-R13 -> R0-R3 para CPURUM

fetch:        ;TODO: progCount doesn't increment properly, consider replacing

        mov.b   progCount(R7), R8       ;move instruction to R8 (IR) 
        add     #1, progCount                   
        
        ret
        
                                        
decode:                                 ;decode by adding total
        jmp     found30                 ;basura, only for TESTING                 
        cmp     #0x00, R8               ;basura
        jeq     foundLoad
foundLoad:
        mov     #load, R9
        jmp     exitDecode
foundStore:
        mov     #store, R9
        jmp     exitDecode
foundAdd:
        mov     #addRegisters, R9
        jmp     exitDecode
foundIn:
        mov     #recieveInput, R9
        jmp     exitDecode
foundOut:
        mov     #output, R9
        jmp     exitDecode
found30:
        mov     #jumpIf30, R9
        jmp     exitDecode
exitDecode:
        ret


execute:
        call    R9
endExecute:
        ret 
        
        
        
        
     
load: 
        ret
store:
        ret
addRegisters:
        ret
negate:
        ret
shiftRight:
        ret

recieveInput:
        ret
output: 
        ret
jumpIf30:
        cmp     #0x0000, R13        
        jeq     is30
        ret
is30:
        ;change progcount value to value in address
        bic.w   #0xFFF0, R8 
        mov     R8, progCount
        ret
        END
