#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

;placing CPURUM Ram at beginning of actual RAM
; Primeros 16 bytes son RAM de CPURUM
        ORG     0x01C00
cpuRAM  ;     INSTRUCTIONS USED TO TEST DECODING
        ; TODO: Cuando movemos valores a registro, padding ocurre por ser 16 bits
        db      0, 0x3f, 0x6f, 0x9f, 0xc3, 0xc5, 0xcf, 0xd6, 0xff, 9, 10, 0, 0, 0, 0
runningInDebugger 
        db      0
progCount
        db      1                       ;testing
instructionMasks                        ; first 6 bits to AND with and get opcode 
        db      0


        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer
        
        MOV.W   #cpuRAM, R7             ; guardar pointer a principio de RAM

        ALIGN   1
        bic.w   0xFFFF, R8            ; R8 -> IR     
        bic.w   0xFFFF, R9
        bic.w   0xFFFF, R10
        bic.w   0xFFFF, R11
        bic.w   0xFFFF, R12
        bic.w   0xFFFF, R13
        CALL    #fetch
        CALL    #decode
        CALL    R9
        ; will place function pointer in R9        
        ;execute instruction stored in R9 after decode
        


        
        JMP $                           ; jump to current location '$'
                                        ; (endless loop)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; R10-R13 -> R0-R3 para CPURUM

fetch:
        mov.b   progCount(R7), R8               ;move instruction to R8 (IR) 
        ;swpb    R8                     ;switching bytes
        
        ;ram[1] -> 0x003f
        add     1, progCount
        
        ret
        
                                        ;decode by adding total
decode:                                 ;argument esta en R8
        cmp     0x00, R8 ;basura
        jeq     foundLoad
        
foundLoad:
        mov     #load, R9
        jmp     exitDecode
foundStore:
        mov     #store, R9
        jmp     exitDecode
foundAdd:
        mov     #addRegisters, R9
        jmp     exitDecode
foundIn:
        mov     #recieveInput, R9
        jmp     exitDecode
foundOut:
        mov     #output, R9
        jmp     exitDecode
found30:
        mov     #jumpIf30, R9
        jmp     exitDecode
exitDecode:
        ret
        
        
        
        
     
load: 
        ret
store:
        ret
addRegisters:
        ret
negate:
        ret
shiftRight:
        ret

recieveInput:
        ret
output: 
        ret
jumpIf30:
        cmp.w   0x0000, R0                              ;program counter  
        jeq     is30
        ret
is30:
        pop.w   R5
        bic.w   0xFFFF, R5
        ;pon address en R0
        mov     0xFFFF, R0
                                             
        END
